use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let root = Path::new(&manifest_dir);
    
    // Paths
    let commands_src = root.join("src").join("commands").join("src");
    let bin_out_dir = root.join("src").join("commands").join("binaries");
    let mod_file_path = root.join("src").join("commands").join("binaries").join("mod.rs");

    // Tell Cargo to rerun this if command source files change
    println!("cargo:rerun-if-changed=src/commands/src");
    println!("cargo:rerun-if-changed=src/api.rs");

    let mut entries = Vec::new();

    if let Ok(dir_entries) = fs::read_dir(&commands_src) {
        fs::create_dir_all(&bin_out_dir).unwrap();

        for entry in dir_entries.flatten() {
            let path = entry.path();
            if path.extension().map_or(false, |ext| ext == "rs") {
                let stem = path.file_stem().unwrap().to_str().unwrap();
                let bin_file_name = format!("{}.bin", stem);
                let bin_path = bin_out_dir.join(&bin_file_name);

                // 1. Compile to a raw binary (No kernel linking needed anymore!)
                // Note: We use -C relocation-model=pic so it can run anywhere in memory
                let output = Command::new("rustc")
                    .args([
                        "--crate-type=bin",
                        "--target", "aarch64-unknown-none",
                        "-C", "opt-level=3",
                        "-C", "relocation-model=pic",
                        "--emit=obj",
                        path.to_str().unwrap(),
                        "-o", bin_path.with_extension("o").to_str().unwrap(),
                    ])
                    .output()
                    .expect("Failed to run rustc");

                if output.status.success() {
                    // 2. Convert object file to raw binary
                    Command::new("rust-objcopy")
                        .args([
                            "-O", "binary",
                            bin_path.with_extension("o").to_str().unwrap(),
                            bin_path.to_str().unwrap(),
                        ])
                        .status()
                        .unwrap();

                    // Cleanup the .o file
                    let _ = fs::remove_file(bin_path.with_extension("o"));

                    // 3. Add to our list for the mod.rs
                    entries.push(format!("    (\"{}\", include_bytes!(\"{}\")),", stem, bin_file_name));
                }
            }
        }
    }

    // 4. Generate the mod.rs content
    let mut content = String::from("// Auto-generated by build.rs - DO NOT EDIT\n\n");
    content.push_str("pub static EMBEDDED_COMMANDS: &[(&str, &[u8])] = &[\n");
    for entry in entries {
        content.push_str(&entry);
        content.push_str("\n");
    }
    content.push_str("];\n");

    fs::write(mod_file_path, content).expect("Failed to write binaries/mod.rs");
}